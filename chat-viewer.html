---
layout: null
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>machine yearning chat</title>
  <!-- Prevent flash by applying theme immediately -->
  <script>
    (function() {
      // Check for saved theme preference or use prefer-color-scheme
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) {
        document.documentElement.setAttribute('data-theme', savedTheme);
      } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.setAttribute('data-theme', 'dark');
      }
      
      // Check for saved animation preference
      const animationEnabled = localStorage.getItem('animationEnabled');
      if (animationEnabled !== null) {
        document.documentElement.setAttribute('data-animation', animationEnabled === 'true' ? 'enabled' : 'disabled');
      } else {
        // Default to enabled
        document.documentElement.setAttribute('data-animation', 'enabled');
      }
    })();
  </script>
  <!-- Add Space Grotesk font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="chat-style.css">
  <!-- Dynamic Prism theme selection -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-solarizedlight.min.css" id="prism-light-theme">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" id="prism-dark-theme" disabled>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-mongodb.min.js"></script>
  <!-- Include showdown.js for Markdown conversion -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
  <!-- Include marked.js for Markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Include the unified chat converter -->
  <script src="chat-converter.js"></script>
  <!-- Include the chat directory scanner -->
  <script src="chats-directory.js"></script>
  <!-- Theme switching script -->
  <script>
    // Function to toggle theme stylesheets
    function togglePrismTheme(isDark) {
      document.getElementById('prism-light-theme').disabled = isDark;
      document.getElementById('prism-dark-theme').disabled = !isDark;
      
      // Re-highlight any code blocks to properly apply the new theme
      if (window.Prism) {
        setTimeout(() => {
          Prism.highlightAll();
          enhanceCodeBlocks(); // Re-add language tag and copy button
        }, 100);
      }
    }
    
    // Apply current theme on load
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
    togglePrismTheme(currentTheme === 'dark');
    
    // Watch for theme changes
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.attributeName === 'data-theme') {
          const theme = document.documentElement.getAttribute('data-theme');
          togglePrismTheme(theme === 'dark');
        }
      });
    });
    
    observer.observe(document.documentElement, { attributes: true });
  </script>
  
  <!-- Script to add language tag and copy button to code blocks -->
  <script>
    function enhanceCodeBlocks() {
      // Find all pre elements
      document.querySelectorAll('pre').forEach(pre => {
        // Skip if already enhanced
        if (pre.querySelector('.code-controls')) return;
        
        // Try to get language
        let language = 'plaintext';
        const codeElement = pre.querySelector('code');
        
        if (codeElement && codeElement.className) {
          const match = codeElement.className.match(/language-(\w+)/);
          if (match) language = match[1];
        }

        // Apply background and padding to pre
        pre.style.padding = "10px";
        pre.style.paddingTop = "10px";
        pre.style.borderRadius = "6px";
        pre.style.backgroundColor = "var(--section-header-bg)";
        
        // Create controls container
        const controls = document.createElement('div');
        controls.className = 'code-controls';
        controls.style.cssText = 'display: flex; justify-content: flex-end; margin: -10px -10px 10px -10px; border-bottom: 1px solid var(--border-color); padding: 5px 10px; background-color: var(--section-header-bg); border-top-left-radius: 6px; border-top-right-radius: 6px;';
        
        // Add lang tag (now first, on the left)
        const langTag = document.createElement('div');
        langTag.className = 'lang-tag';
        langTag.style.cssText = 'padding: 2px 6px; font-size: 12px; text-transform: lowercase; color: var(--text-color); font-weight: bold; display: flex; align-items: center; margin-right: auto;';
        langTag.textContent = language;
        
        // Add copy button with SVG (now on the right)
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-button';
        copyBtn.style.cssText = 'background: transparent; color: var(--text-color); border: none; cursor: pointer; display: flex; align-items: center; padding: 3px; border-radius: 4px;';
        copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        
        copyBtn.onmouseover = function() {
          this.style.backgroundColor = 'var(--border-color)';
        };
        
        copyBtn.onmouseout = function() {
          this.style.backgroundColor = 'transparent';
        };
        
        copyBtn.onclick = function() {
          const code = codeElement ? codeElement.textContent : pre.textContent;
          navigator.clipboard.writeText(code);
          this.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
          setTimeout(() => { 
            this.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
          }, 2000);
        };
        
        // Append elements (lang tag first, copy button last)
        controls.appendChild(langTag);
        controls.appendChild(copyBtn);
        
        // Insert at the beginning of the pre element
        pre.insertBefore(controls, pre.firstChild);
      });
    }
    
    // Run once when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(enhanceCodeBlocks, 1000);
    });
  </script>
</head>
<body>
  <div class="site-header">
    <a href="index.html" class="site-title">
      <h1>machine yearning</h1>
    </a>
    <div class="header-controls">
      <button id="animation-toggle" class="animation-toggle" aria-label="Toggle typing animation">
        <svg class="enabled-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <circle cx="5" cy="12" r="2" />
          <circle cx="12" cy="12" r="2" />
          <circle cx="19" cy="12" r="2" />
        </svg>
        <svg class="disabled-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M5 10h14v4H5z" />
        </svg>
      </button>
      <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">
        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm-9 4.5H1v-3h2v3zm20 0h-2v-3h2v3zM12 1v2c0 .55-.45 1-1 1s-1-.45-1-1V1h2zm0 20v2h-2v-2c0-.55.45-1 1-1s1 .45 1 1zm7.4-15.4l-1.4 1.4c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41l1.4-1.4 1.41 1.41zM5.99 19.41l-1.4 1.4-1.41-1.41 1.4-1.4c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41z"/>
        </svg>
        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/>
        </svg>
      </button>
    </div>
  </div>
  
  <div class="chat-nav">
    <a href="#" class="nav-link prev-link" id="prevLink">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
      </svg>
    </a>
    <h2 class="chat-title" id="chat-nav-title">Loading conversation...</h2>
    <a href="#" class="nav-link next-link" id="nextLink">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
      </svg>
    </a>
  </div>
  
  <div id="chat-container">
    <div id="loading" class="loading-indicator">Loading conversation...</div>
    <div id="markdown-content" class="markdown-body" style="display: none;"></div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Theme toggle functionality
      const toggleButton = document.getElementById('theme-toggle');
      
      // Toggle theme on button click
      toggleButton.addEventListener('click', function() {
        const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        
        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        
        // Optionally re-highlight code to pick up theme changes
        if (window.Prism) {
          setTimeout(() => Prism.highlightAll(), 50);
        }
      });
      
      // Animation toggle functionality
      const animationToggle = document.getElementById('animation-toggle');
      
      // Set initial toggle state
      const animationState = document.documentElement.getAttribute('data-animation') || 'enabled';
      const toggleClass = animationState === 'enabled' ? 'enabled' : 'disabled';
      animationToggle.setAttribute('data-state', toggleClass);
      
      // Toggle animation on button click
      animationToggle.addEventListener('click', function() {
        const currentState = document.documentElement.getAttribute('data-animation') || 'enabled';
        const newState = currentState === 'enabled' ? 'disabled' : 'enabled';
        
        document.documentElement.setAttribute('data-animation', newState);
        localStorage.setItem('animationEnabled', newState === 'enabled');
        
        // Update toggle button state
        animationToggle.setAttribute('data-state', newState === 'enabled' ? 'enabled' : 'disabled');
        
        // Apply animation state to messages
        applyAnimationState(newState === 'enabled');
      });
      
      // Get the conversation path from URL
      const urlParams = new URLSearchParams(window.location.search);
      const path = urlParams.get('path');
      
      if (!path) {
        document.getElementById('loading').textContent = 'Error: No conversation specified';
        return;
      }

      // Main function to load and display the chat
      const loadChat = async () => {
        try {
          // Initialize the chat scanner
          await window.chatScanner.init();
          
          // Set up navigation using the scanner
          const navigation = window.chatScanner.getNavigation(path);
          updateNavigation(navigation);
          
          // Fetch the markdown file
          const response = await fetch(path);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          
          const markdown = await response.text();
          
          // Extract title from markdown if available
          const titleMatch = markdown.match(/^#\s+(.+)$/m);
          const fileName = path.split('/').pop().replace('.md', '');
          const pageTitle = titleMatch ? titleMatch[1].trim() : fileName;
          
          // Update page title and navigation title
          document.title = `machine yearning - ${pageTitle}`;
          document.getElementById('chat-nav-title').textContent = pageTitle;
          
          // Display the markdown
          const markdownContent = document.getElementById('markdown-content');
          markdownContent.style.display = 'block';
          document.getElementById('loading').style.display = 'none';
          
          // Initialize the chat converter with our fetched content
          initChatConverter({
            rawMarkdown: markdown,
            navConfig: {
              prevLink: navigation.prev ? `chat-viewer.html?path=${navigation.prev.path}` : null,
              nextLink: navigation.next ? `chat-viewer.html?path=${navigation.next.path}` : null,
              title: pageTitle
            },
            showTitle: false
          });
          
          // Enhance code blocks once chat is converted
          setTimeout(() => {
            enhanceCodeBlocks();
            setupAnimations();
          }, 500);
        } catch (error) {
          console.error('Error loading chat:', error);
          document.getElementById('loading').textContent = `Error loading conversation: ${error.message}`;
        }
      };
      
      // Update the navigation links
      function updateNavigation(navigation) {
        const prevLink = document.getElementById('prevLink');
        const nextLink = document.getElementById('nextLink');
        
        if (navigation.prev) {
          prevLink.href = `chat-viewer.html?path=${navigation.prev.path}`;
          prevLink.classList.remove('disabled');
        } else {
          prevLink.classList.add('disabled');
          prevLink.href = '#';
        }
        
        if (navigation.next) {
          nextLink.href = `chat-viewer.html?path=${navigation.next.path}`;
          nextLink.classList.remove('disabled');
        } else {
          nextLink.classList.add('disabled');
          nextLink.href = '#';
        }
      }
      
      // Setup animations for sequential message display
      function setupAnimations() {
        const animationEnabled = document.documentElement.getAttribute('data-animation') === 'enabled';
        
        // Get all messages
        const messages = document.querySelectorAll('.message');
        
        // Remove any existing typing indicators
        document.querySelectorAll('.typing-indicator').forEach(indicator => {
          indicator.remove();
        });
        
        if (!animationEnabled) {
          // If animations are disabled, make sure all messages are visible
          messages.forEach(msg => {
            msg.classList.remove('hidden');
            msg.classList.add('visible');
          });
          return;
        }
        
        // Hide all messages initially except the first
        messages.forEach((msg, index) => {
          if (index === 0) {
            msg.classList.add('visible');
            msg.classList.remove('hidden');
          } else {
            msg.classList.add('hidden');
            msg.classList.remove('visible');
          }
        });
        
        // Set up intersection observer to reveal messages as they scroll into view
        setupScrollObservers();
      }
      
      // Set up scroll-based observers for animation
      function setupScrollObservers() {
        // Get all messages
        const messages = document.querySelectorAll('.message');
        
        // Create observer for messages
        const messageObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
              const currentMsg = entry.target;
              const index = Array.from(messages).indexOf(currentMsg);
              
              // Show this message if it's not already visible
              if (currentMsg.classList.contains('hidden')) {
                currentMsg.classList.remove('hidden');
                currentMsg.classList.add('visible');
              }
              
              // Check if there's a next message to reveal
              if (index < messages.length - 1) {
                const nextMsg = messages[index + 1];
                
                // Add a small delay before showing the next message
                setTimeout(() => {
                  // Start observing the next message
                  messageObserver.observe(nextMsg);
                }, 300);
              }
              
              // Stop observing this message
              messageObserver.unobserve(currentMsg);
            }
          });
        }, {
          threshold: 0.5,
          rootMargin: "0px 0px -100px 0px" // Trigger when message is in view with space below
        });
        
        // Start by observing the first message
        if (messages.length > 0) {
          messageObserver.observe(messages[0]);
        }
        
        // Also start observing any messages that are at the top of the viewport
        messages.forEach((msg, index) => {
          const rect = msg.getBoundingClientRect();
          if (rect.top < window.innerHeight && rect.bottom > 0) {
            messageObserver.observe(msg);
          }
        });
      }
      
      // Apply animation state change (enable/disable)
      function applyAnimationState(enabled) {
        document.documentElement.setAttribute('data-animation', enabled ? 'enabled' : 'disabled');
        
        // Get all messages and typing indicators
        const messages = document.querySelectorAll('.message');
        const typingIndicators = document.querySelectorAll('.typing-indicator');
        
        if (!enabled) {
          // Show all messages and hide all typing indicators
          messages.forEach(msg => {
            msg.classList.remove('hidden');
            msg.classList.add('visible');
          });
          
          typingIndicators.forEach(indicator => {
            indicator.classList.remove('visible');
          });
        } else {
          // Reset and re-initialize animations
          messages.forEach(msg => {
            msg.classList.remove('visible');
            msg.classList.add('hidden');
          });
          
          typingIndicators.forEach(indicator => {
            indicator.classList.remove('visible');
          });
          
          // Setup animations from scratch
          setupAnimations();
        }
      }
      
      // Start loading the chat
      loadChat();
    });
  </script>
  
  <style>
    .loading-indicator {
      text-align: center;
      padding: 2rem;
      color: var(--muted-color);
      font-style: italic;
    }
    
    .header-controls {
      display: flex;
      align-items: center;
    }
  </style>
</body>
</html> 