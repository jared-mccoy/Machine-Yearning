---
layout: null
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>machine yearning chat</title>
  <<<Prevent flash by applying theme immediately>>>
  <script>
    (function() {
      // Check for saved theme preference or use prefer-color-scheme
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) {
        document.documentElement.setAttribute('data-theme', savedTheme);
      } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.setAttribute('data-theme', 'dark');
      }
      
      // Check for saved animation preference
      const animationEnabled = localStorage.getItem('animationEnabled');
      if (animationEnabled !== null) {
        document.documentElement.setAttribute('data-animation', animationEnabled === 'true' ? 'enabled' : 'disabled');
      } else {
        // Default to enabled
        document.documentElement.setAttribute('data-animation', 'enabled');
      }
    })();
  </script>
  <<<Add Space Grotesk font>>>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="chat-style.css">
  <<<Dynamic Prism theme selection>>>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-solarizedlight.min.css" id="prism-light-theme">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" id="prism-dark-theme" disabled>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-mongodb.min.js"></script>
  <<<Include showdown.js for Markdown conversion>>>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
  <<<Include marked.js for Markdown parsing>>>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <<<Include the unified chat converter>>>
  <script src="chat-converter.js"></script>
  <<<Include the chat directory scanner>>>
  <script src="chats-directory.js"></script>
  <<<Theme switching script>>>
  <script>
    // Function to toggle theme stylesheets
    function togglePrismTheme(isDark) {
      document.getElementById('prism-light-theme').disabled = isDark;
      document.getElementById('prism-dark-theme').disabled = !isDark;
      
      // Re-highlight any code blocks to properly apply the new theme
      if (window.Prism) {
        setTimeout(() => {
          Prism.highlightAll();
          enhanceCodeBlocks(); // Re-add language tag and copy button
        }, 100);
      }
    }
    
    // Apply current theme on load
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
    togglePrismTheme(currentTheme === 'dark');
    
    // Watch for theme changes
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.attributeName === 'data-theme') {
          const theme = document.documentElement.getAttribute('data-theme');
          togglePrismTheme(theme === 'dark');
        }
      });
    });
    
    observer.observe(document.documentElement, { attributes: true });
  </script>
  
  <<<Script to add language tag and copy button to code blocks>>>
  <script>
    function enhanceCodeBlocks() {
      // Find all pre elements
      document.querySelectorAll('pre').forEach(pre => {
        // Skip if already enhanced
        if (pre.querySelector('.code-controls')) return;
        
        // Try to get language
        let language = 'plaintext';
        const codeElement = pre.querySelector('code');
        
        if (codeElement && codeElement.className) {
          const match = codeElement.className.match(/language-(\w+)/);
          if (match) language = match[1];
        }

        // Apply background and padding to pre
        pre.style.padding = "10px";
        pre.style.paddingTop = "10px";
        pre.style.borderRadius = "6px";
        pre.style.backgroundColor = "var(--section-header-bg)";
        
        // Create controls container
        const controls = document.createElement('div');
        controls.className = 'code-controls';
        controls.style.cssText = 'display: flex; justify-content: flex-end; margin: -10px -10px 10px -10px; border-bottom: 1px solid var(--border-color); padding: 5px 10px; background-color: var(--section-header-bg); border-top-left-radius: 6px; border-top-right-radius: 6px;';
        
        // Add lang tag (now first, on the left)
        const langTag = document.createElement('div');
        langTag.className = 'lang-tag';
        langTag.style.cssText = 'padding: 2px 6px; font-size: 12px; text-transform: lowercase; color: var(--text-color); font-weight: bold; display: flex; align-items: center; margin-right: auto;';
        langTag.textContent = language;
        
        // Add copy button with SVG (now on the right)
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-button';
        copyBtn.style.cssText = 'background: transparent; color: var(--text-color); border: none; cursor: pointer; display: flex; align-items: center; padding: 3px; border-radius: 4px;';
        copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        
        copyBtn.onmouseover = function() {
          this.style.backgroundColor = 'var(--border-color)';
        };
        
        copyBtn.onmouseout = function() {
          this.style.backgroundColor = 'transparent';
        };
        
        copyBtn.onclick = function() {
          const code = codeElement ? codeElement.textContent : pre.textContent;
          navigator.clipboard.writeText(code);
          this.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
          setTimeout(() => { 
            this.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
          }, 2000);
        };
        
        // Append elements (lang tag first, copy button last)
        controls.appendChild(langTag);
        controls.appendChild(copyBtn);
        
        // Insert at the beginning of the pre element
        pre.insertBefore(controls, pre.firstChild);
      });
    }
    
    // Run once when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(enhanceCodeBlocks, 1000);
    });
  </script>
</head>
<body>
  <div class="site-header">
    <a href="index.html" class="site-title">
      <h1>machine yearning</h1>
    </a>
    <div class="header-controls">
      <button id="animation-toggle" class="animation-toggle" aria-label="Toggle typing animation">
        <svg class="enabled-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <circle cx="5" cy="12" r="2" />
          <circle cx="12" cy="12" r="2" />
          <circle cx="19" cy="12" r="2" />
        </svg>
        <svg class="disabled-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M5 10h14v4H5z" />
        </svg>
      </button>
      <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">
        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm-9 4.5H1v-3h2v3zm20 0h-2v-3h2v3zM12 1v2c0 .55-.45 1-1 1s-1-.45-1-1V1h2zm0 20v2h-2v-2c0-.55.45-1 1-1s1 .45 1 1zm7.4-15.4l-1.4 1.4c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41l1.4-1.4 1.41 1.41zM5.99 19.41l-1.4 1.4-1.41-1.41 1.4-1.4c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41z"/>
        </svg>
        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/>
        </svg>
      </button>
    </div>
  </div>
  
  <div class="chat-nav">
    <a href="#" class="nav-link prev-link" id="prevLink">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
      </svg>
    </a>
    <h2 class="chat-title" id="chat-nav-title">Loading conversation...</h2>
    <a href="#" class="nav-link next-link" id="nextLink">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
      </svg>
    </a>
  </div>
  
  <div id="chat-container">
    <div id="loading" class="loading-indicator"></div>
    <div id="markdown-content" class="markdown-body" style="display: none;"></div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Theme toggle functionality
      const toggleButton = document.getElementById('theme-toggle');
      
      // Toggle theme on button click
      toggleButton.addEventListener('click', function() {
        const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        
        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        
        // Optionally re-highlight code to pick up theme changes
        if (window.Prism) {
          setTimeout(() => Prism.highlightAll(), 50);
        }
      });
      
      // Animation toggle functionality
      const animationToggle = document.getElementById('animation-toggle');
      
      // Set initial toggle state
      const animationState = document.documentElement.getAttribute('data-animation') || 'enabled';
      const toggleClass = animationState === 'enabled' ? 'enabled' : 'disabled';
      animationToggle.setAttribute('data-state', toggleClass);
      
      // Toggle animation on button click
      animationToggle.addEventListener('click', function() {
        const currentState = document.documentElement.getAttribute('data-animation') || 'enabled';
        const newState = currentState === 'enabled' ? 'disabled' : 'enabled';
        
        document.documentElement.setAttribute('data-animation', newState);
        localStorage.setItem('animationEnabled', newState === 'enabled');
        
        // Update toggle button state
        animationToggle.setAttribute('data-state', newState === 'enabled' ? 'enabled' : 'disabled');
        
        // Remove any typing indicators
        document.querySelectorAll('.typing-indicator').forEach(indicator => {
          indicator.classList.remove('visible');
          indicator.remove();
        });
        
        // Clear queue state
        window.animationQueue = [];
        window.animationFailedMessages = [];
        window.animationInProgress = false;
        window.typingIndicatorVisible = false;
        
        // Apply animation state to messages
        const messages = document.querySelectorAll('.message');
        
        if (newState === 'disabled') {
          // Show all messages immediately when disabling animations
          messages.forEach(msg => {
            msg.removeAttribute('data-observed');
            msg.classList.remove('hidden');
            msg.classList.add('visible');
          });
        } else {
          // Reset for animation
          messages.forEach(msg => {
            msg.removeAttribute('data-observed');
            msg.classList.remove('visible');
            msg.classList.add('hidden');
          });
          
          // Setup animations from scratch
          setupAnimations();
        }
      });
      
      // Get the conversation path from URL
      const urlParams = new URLSearchParams(window.location.search);
      const path = urlParams.get('path');
      
      if (!path) {
        document.getElementById('loading').textContent = 'Error: No conversation specified';
        return;
      }

      // Main function to load and display the chat
      const loadChat = async () => {
        try {
          // Immediately convert the loading div to a typing animation
          const loadingIndicator = document.getElementById('loading');
          loadingIndicator.className = 'typing-indicator initial-loader';
          loadingIndicator.innerHTML = '<span></span><span></span><span></span>';
          loadingIndicator.classList.add('visible');
          
          // Minimum typing animation duration for initial loading
          const MIN_TYPING_DURATION = 1200;
          const startTime = Date.now();
          
          // Initialize the chat scanner
          await window.chatScanner.init();
          
          // Set up navigation using the scanner
          const navigation = window.chatScanner.getNavigation(path);
          updateNavigation(navigation);
          
          // Fetch the markdown file
          const response = await fetch(path);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          
          const markdown = await response.text();
          
          // Extract title from markdown if available
          const titleMatch = markdown.match(/^#\s+(.+)$/m);
          const fileName = path.split('/').pop().replace('.md', '');
          const pageTitle = titleMatch ? titleMatch[1].trim() : fileName;
          
          // Update page title and navigation title
          document.title = `machine yearning - ${pageTitle}`;
          document.getElementById('chat-nav-title').textContent = pageTitle;
          
          // Short delay before displaying the markdown content
          const markdownContent = document.getElementById('markdown-content');
          
          // Initialize the chat converter with our fetched content - but don't display it yet
          initChatConverter({
            rawMarkdown: markdown,
            navConfig: {
              prevLink: navigation.prev ? `chat-viewer.html?path=${navigation.prev.path}` : null,
              nextLink: navigation.next ? `chat-viewer.html?path=${navigation.next.path}` : null,
              title: pageTitle
            },
            showTitle: false
          });
          
          // Calculate elapsed time so far
          let elapsed = Date.now() - startTime;
          let remainingDelay = Math.max(0, MIN_TYPING_DURATION - elapsed);
          
          // Wait for content to be ready, ensuring we meet minimum typing duration
          setTimeout(() => {
            // Show the content container (but keep messages hidden)
            markdownContent.style.display = 'block';
            
            // Enhance code blocks
            enhanceCodeBlocks();
            
            // Get all messages after content is rendered
            const messages = document.querySelectorAll('.message');
            
            // Hide all messages initially
            messages.forEach(msg => {
              msg.classList.add('hidden');
              msg.classList.remove('visible');
            });
            
            // Prepare to position the typing indicator for the first message
            const firstMessage = messages[0];
            if (firstMessage && firstMessage.parentNode) {
              // Move the loading indicator to be positioned exactly where the first message will appear
              firstMessage.parentNode.insertBefore(loadingIndicator, firstMessage);
              
              // Now wait for the remaining minimum typing time before showing the first message
              const totalElapsed = Date.now() - startTime;
              const finalDelay = Math.max(0, MIN_TYPING_DURATION - totalElapsed);
              
              setTimeout(() => {
                // Hide the typing indicator with fade-out
                loadingIndicator.classList.remove('visible');
                
                // After animation completes, show the first message
                setTimeout(() => {
                  // Remove the typing indicator
                  loadingIndicator.remove();
                  
                  // Show first message
                  firstMessage.classList.remove('hidden');
                  firstMessage.classList.add('visible');
                  firstMessage.setAttribute('data-observed', 'processed');
                  
                  // Setup animations for the rest after first message is shown
                  setTimeout(() => {
                    setupAnimations(true); // Pass true to indicate first message is already shown
                  }, 100);
                }, 300);
              }, finalDelay);
            } else {
              // Edge case: no messages found
              loadingIndicator.remove();
              setupAnimations();
            }
          }, 300);
        } catch (error) {
          console.error('Error loading chat:', error);
          document.getElementById('loading').textContent = `Error loading conversation: ${error.message}`;
        }
      };
      
      // Update the navigation links
      function updateNavigation(navigation) {
        const prevLink = document.getElementById('prevLink');
        const nextLink = document.getElementById('nextLink');
        
        if (navigation.prev) {
          prevLink.href = `chat-viewer.html?path=${navigation.prev.path}`;
          prevLink.classList.remove('disabled');
        } else {
          prevLink.classList.add('disabled');
          prevLink.href = '#';
        }
        
        if (navigation.next) {
          nextLink.href = `chat-viewer.html?path=${navigation.next.path}`;
          nextLink.classList.remove('disabled');
        } else {
          nextLink.classList.add('disabled');
          nextLink.href = '#';
        }
      }
      
      // Setup animations for sequential message display
      function setupAnimations(firstMessageShown = false) {
        const animationEnabled = document.documentElement.getAttribute('data-animation') === 'enabled';
        
        // Get all messages
        const messages = document.querySelectorAll('.message');
        
        // Remove any existing typing indicators
        document.querySelectorAll('.typing-indicator:not(.initial-loader)').forEach(indicator => {
          indicator.remove();
        });
        
        if (!animationEnabled) {
          // If animations are disabled, make sure all messages are visible
          messages.forEach(msg => {
            msg.classList.remove('hidden');
            msg.classList.add('visible');
          });
          return;
        }
        
        // Hide all messages initially except the first
        messages.forEach((msg, index) => {
          if (index === 0 && firstMessageShown) {
            // First message already shown by loading animation
            msg.classList.add('visible');
            msg.classList.remove('hidden');
            msg.setAttribute('data-observed', 'processed');
          } else if (index === 0) {
            // First message should be shown if not already
            msg.classList.add('visible');
            msg.classList.remove('hidden');
            msg.setAttribute('data-observed', 'processed');
          } else {
            // All other messages remain hidden for animation
            msg.classList.add('hidden');
            msg.classList.remove('visible');
          }
        });
        
        // Set up intersection observer to reveal messages as they scroll into view
        setupScrollObservers();
      }
      
      // Set up scroll-based observers for animation
      function setupScrollObservers() {
        // Get all messages
        const messages = document.querySelectorAll('.message');
        
        // Animation queue and state management
        let animationInProgress = false;
        let messageQueue = [];
        let lastSenderWasUser = false; // Track which type of message was last shown
        let animationFailedMessages = []; // Keep track of messages that failed to show
        let typingIndicatorVisible = false; // Track if a typing indicator is currently visible
        
        // Function to process the next message in queue
        function processNextInQueue() {
          if (messageQueue.length === 0 || animationInProgress || typingIndicatorVisible) {
            return;
          }
          
          // Check for failed messages first and add them back to the front of the queue
          if (animationFailedMessages.length > 0) {
            // Add them in reverse order to maintain original sequence
            for (let i = animationFailedMessages.length - 1; i >= 0; i--) {
              messageQueue.unshift(animationFailedMessages[i]);
            }
            animationFailedMessages = [];
          }
          
          // Get the next message
          const nextMsg = messageQueue[0];
          const isUser = nextMsg.classList.contains('user');
          
          // Skip if message is already visible (prevent double animations)
          if (nextMsg.classList.contains('visible')) {
            messageQueue.shift(); // Remove from queue
            processNextInQueue(); // Process next message
            return;
          }
          
          // During initial load, enforce alternating pattern 
          if (messageQueue.length > 1 && document.querySelectorAll('.message.visible').length < 3) {
            // If last message shown was from user, next should be assistant and vice versa
            if ((lastSenderWasUser && isUser) || (!lastSenderWasUser && !isUser)) {
              // Look for next message of correct type
              let foundAlternate = false;
              for (let i = 1; i < messageQueue.length; i++) {
                const alternateMsg = messageQueue[i];
                if (isUser !== alternateMsg.classList.contains('user') && 
                    !alternateMsg.classList.contains('visible')) { 
                  // Swap this message to front of queue to maintain alternation
                  messageQueue.splice(i, 1);
                  messageQueue.unshift(alternateMsg);
                  foundAlternate = true;
                  break;
                }
              }
            }
          }
          
          // Now process the message at the front of the queue
          animationInProgress = true;
          const currentMsg = messageQueue.shift();
          const currentIsUser = currentMsg.classList.contains('user');
          
          // Get the visible message count
          const visibleCount = document.querySelectorAll('.message.visible').length;
          
          // Skip animation for the first few messages to get things started
          if (visibleCount < 1) {
            // First message should be visible immediately without animation
            currentMsg.classList.remove('hidden');
            currentMsg.classList.add('visible');
            currentMsg.setAttribute('data-observed', 'processed');
            lastSenderWasUser = currentIsUser;
            
            // Move to next message immediately
            setTimeout(() => {
              animationInProgress = false;
              processNextInQueue();
            }, 100);
            return;
          }
          
          // Create typing indicator with appropriate class
          const typingIndicator = document.createElement('div');
          typingIndicator.className = currentIsUser ? 'typing-indicator user-typing' : 'typing-indicator';
          typingIndicator.innerHTML = '<span></span><span></span><span></span>';
          
          // Store reference to current message
          typingIndicator.messageReference = currentMsg;
          
          // Mark message as processed to avoid double animations
          currentMsg.setAttribute('data-observed', 'processed');
          
          // Find the chat container
          const container = document.querySelector('#markdown-content') || currentMsg.parentNode;
          
          // Find all visible messages to position indicator correctly
          const visibleMessages = Array.from(document.querySelectorAll('.message.visible'));
          
          // Position the typing indicator after the last visible message
          if (visibleMessages.length > 0) {
            const lastVisible = visibleMessages[visibleMessages.length - 1];
            lastVisible.after(typingIndicator);
          } else {
            // If no visible messages yet, add to beginning of container
            container.prepend(typingIndicator);
          }
          
          // Flag that there's a typing indicator showing
          typingIndicatorVisible = true;
          
          // Show the typing indicator with a small delay
          setTimeout(() => {
            typingIndicator.classList.add('visible');
          }, 50);
          
          // After typing animation completes, show the message
          setTimeout(() => {
            // Hide the typing indicator
            typingIndicator.classList.remove('visible');
            typingIndicatorVisible = false;
            
            // Relax the viewport check - just make sure message is near viewport
            // We'll show even if just the top is visible or close to visible
            const rect = currentMsg.getBoundingClientRect();
            
            // Consider a message "in view" if it's even partially in viewport or within 300px below
            const isInView = rect.top < window.innerHeight + 300;
            
            // If it's anywhere close to view, show the message
            if (isInView) {
              // Update the last sender type
              lastSenderWasUser = currentIsUser;
              
              // Show the message with animation
              currentMsg.classList.remove('hidden');
              currentMsg.classList.add('visible');
              
              // Remove the indicator after its transition completes
              setTimeout(() => typingIndicator.remove(), 300);
              
              // Wait for message animation to complete before processing next
              setTimeout(() => {
                animationInProgress = false;
                processNextInQueue();
              }, 600);
            } else {
              // Message is really far from viewport, don't show it yet
              console.log("Message far from viewport, will retry later");
              
              // Remove the indicator immediately since we're not showing the message
              typingIndicator.remove();
              
              // Add message to failed list to retry later
              animationFailedMessages.push(currentMsg);
              
              // Set a retry timeout that's shorter than normal animation
              setTimeout(() => {
                animationInProgress = false;
                processNextInQueue();
              }, 300);
            }
          }, currentIsUser ? 800 : 1200); // Shorter typing time for user messages
        }
        
        // Create observer for messages with a more sensitive threshold
        const messageObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const currentMsg = entry.target;
            
            // Process when message enters viewport or gets close to it
            if (entry.isIntersecting || entry.intersectionRatio > 0.05) {
              const index = Array.from(messages).indexOf(currentMsg);
              
              // Ensure we're handling this message if it's not processed yet
              if (!currentMsg.hasAttribute('data-observed') || currentMsg.classList.contains('hidden')) {
                // Mark as observed
                currentMsg.setAttribute('data-observed', 'true');
                
                // Queue this message if it's not already visible and not already queued
                if (currentMsg.classList.contains('hidden') && 
                    !messageQueue.includes(currentMsg) && 
                    !animationFailedMessages.includes(currentMsg)) {
                  messageQueue.push(currentMsg);
                  processNextInQueue();
                }
                
                // Always check if there are more messages to queue
                checkFollowingMessages(index);
              }
              
              // If message is fully visible, stop observing 
              if (entry.intersectionRatio > 0.8 || currentMsg.classList.contains('visible')) {
                messageObserver.unobserve(currentMsg);
              }
            }
          });
        }, {
          threshold: [0.05, 0.5, 0.8], // Observe at multiple thresholds
          rootMargin: "0px 0px 300px 0px" // Extend bottom margin to detect earlier - increased to 300px
        });
        
        // Helper function to check and queue following messages
        function checkFollowingMessages(currentIndex) {
          // Check for next messages to reveal
          if (currentIndex < messages.length - 1) {
            // Look ahead for up to 3 messages
            const lookaheadCount = Math.min(3, messages.length - currentIndex - 1);
            
            for (let i = 1; i <= lookaheadCount; i++) {
              const nextMsg = messages[currentIndex + i];
              
              // Skip if already being processed
              if (nextMsg.hasAttribute('data-observed') && !nextMsg.classList.contains('hidden')) {
                continue;
              }
              
              // Check if in view or near viewport
              const rect = nextMsg.getBoundingClientRect();
              const distanceFromViewport = rect.top - window.innerHeight;
              
              // Queue if within generous range
              if (distanceFromViewport < 800) { // Very generous lookahead for end of page
                if (nextMsg.classList.contains('hidden') && 
                    !messageQueue.includes(nextMsg) && 
                    !animationFailedMessages.includes(nextMsg)) {
                  // Mark message for observation
                  nextMsg.setAttribute('data-observed', 'true');
                  messageQueue.push(nextMsg);
                  processNextInQueue();
                }
              }
              
              // Always observe the next message for better tracking
              messageObserver.observe(nextMsg);
            }
          }
        }
        
        // Start by observing the first message
        if (messages.length > 0) {
          // Check if the first message is user or assistant to set initial state
          const firstMsg = messages[0];
          if (firstMsg.classList.contains('user')) {
            lastSenderWasUser = true;
          }
          
          // Mark first message as already processed and make it visible immediately
          firstMsg.setAttribute('data-observed', 'processed');
          firstMsg.classList.remove('hidden');
          firstMsg.classList.add('visible');
          
          // Start observing the second message instead
          if (messages.length > 1) {
            const secondMsg = messages[1];
            if (!secondMsg.hasAttribute('data-observed')) {
              messageObserver.observe(secondMsg);
              
              // Pre-queue the second message to start animations
              secondMsg.setAttribute('data-observed', 'true');
              messageQueue.push(secondMsg);
              
              // Also observe third message if it exists
              if (messages.length > 2) {
                messageObserver.observe(messages[2]);
              }
            }
          }
        }
        
        // Add scroll event listener for more aggressive message queueing at page bottom
        window.addEventListener('scroll', function() {
          // Handle failed messages
          if (animationFailedMessages.length > 0 && !animationInProgress && !typingIndicatorVisible) {
            clearTimeout(window.scrollDebounceTimer);
            window.scrollDebounceTimer = setTimeout(() => {
              processNextInQueue();
            }, 100);
            return;
          }
          
          // Check if we're near the bottom of the page
          const scrollPosition = window.scrollY + window.innerHeight;
          const pageHeight = document.documentElement.scrollHeight;
          const isNearBottom = (pageHeight - scrollPosition) < 300;
          
          if (isNearBottom) {
            // Find the last visible message
            const visibleMessages = Array.from(document.querySelectorAll('.message.visible'));
            if (visibleMessages.length > 0) {
              const lastVisible = visibleMessages[visibleMessages.length - 1];
              const lastVisibleIndex = Array.from(messages).indexOf(lastVisible);
              
              // Queue more messages when near the bottom
              checkFollowingMessages(lastVisibleIndex);
            }
          }
        }, { passive: true });
        
        // Also start observing more initial messages
        const initialVisibleCount = Math.min(8, messages.length); // Increased from 6 to 8
        for (let i = 0; i < initialVisibleCount; i++) {
          const msg = messages[i];
          const rect = msg.getBoundingClientRect();
          if (rect.top < window.innerHeight + 800) { // Much more generous initial observation range
            messageObserver.observe(msg);
            msg.setAttribute('data-observed', 'true');
          }
        }
      }
      
      // Start loading the chat
      loadChat();
    });
  </script>
  
  <style>
    .loading-indicator {
      text-align: center;
      padding: 2rem;
      color: var(--muted-color);
      font-style: italic;
    }
    
    .header-controls {
      display: flex;
      align-items: center;
    }
    
    /* Styling for the initial loading indicator */
    .initial-loader {
      text-align: center;
      padding: 3rem;
      margin: 2rem auto;
      max-width: 100px;
    }
    
    .initial-loader span {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: var(--accent-color);
      margin: 0 6px;
      animation: bounce 1.4s infinite ease-in-out both;
    }
    
    .initial-loader span:nth-child(1) {
      animation-delay: -0.32s;
    }
    
    .initial-loader span:nth-child(2) {
      animation-delay: -0.16s;
    }
    
    @keyframes bounce {
      0%, 80%, 100% { 
        transform: scale(0);
      } 
      40% { 
        transform: scale(1.0);
      }
    }
  </style>
</body>
</html> 